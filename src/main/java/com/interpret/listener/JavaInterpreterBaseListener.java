package com.interpret.listener;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.ParseTreeWalker;
import org.antlr.v4.runtime.tree.TerminalNode;

import com.actions.ActionType;
import com.actions.JavaAction;
import com.actions.JavaClass;
import com.actions.JavaEnum;
import com.actions.JavaException;
import com.actions.JavaImport;
import com.actions.JavaLoopOrIfStatement;
import com.antlr.Java8BaseListener;
import com.antlr.Java8Lexer;
import com.antlr.Java8Parser;
import com.antlr.Java8Parser.CatchClauseContext;
import com.antlr.Java8Parser.ClassDeclarationContext;
import com.antlr.Java8Parser.DoStatementContext;
import com.antlr.Java8Parser.EnumDeclarationContext;
import com.antlr.Java8Parser.ExpressionStatementContext;
import com.antlr.Java8Parser.FieldDeclarationContext;
import com.antlr.Java8Parser.ForStatementContext;
import com.antlr.Java8Parser.IfThenElseStatementContext;
import com.antlr.Java8Parser.IfThenStatementContext;
import com.antlr.Java8Parser.ImportDeclarationContext;
import com.antlr.Java8Parser.MethodDeclarationContext;
import com.antlr.Java8Parser.NormalClassDeclarationContext;
import com.antlr.Java8Parser.WhileStatementContext;
import com.interpret.JavaInterpreterMaps;

/**
 * Class that extends {@link Java8BaseListener}, the base listener generated by ANTLR. But, here we figure out
 * the topmost part of the parse tree we care about and then pass the input along into the nested listener we created for
 * each of these topmost trees.
 *
 * @author <a href="mailto:mxt4877@rit.edu">Mike Thomsen</a>
 */
public class JavaInterpreterBaseListener extends Java8BaseListener {
	
	/**
	 * The actual input.
	 */
	private String rawInput;
	
	/**
	 * The new action we are going to create here.
	 */
	private JavaAction newAction;
	
	/**
	 * The constructor that takes the raw input in.
	 * 
	 * @param rawInput -- the raw input.
	 */
	public JavaInterpreterBaseListener(String rawInput) {
		this.rawInput = rawInput;
	}
	
	@Override
	public void enterFieldDeclaration(FieldDeclarationContext feildDeclarationContext) {
		
		// It's possible that fields are nested (for example inside of a class or method). We don't care about those, really so don't do any processing.
		if(this.newAction != null) {
			return;
		}
		
		// Find the relevant dependencies.
		Set<JavaAction> dependentActions = getDependentActions(findIdentifiers(feildDeclarationContext));
		
		// Go walk this specifically.
		Java8Parser newParser = getNewParser();
		
		// Pass through the raw input to the field listener.
		JavaFieldListener listener = new JavaFieldListener(rawInput);
		
		// Get the walker and walk with the new listener.
		ParseTreeWalker walker = new ParseTreeWalker();
		walker.walk(listener, newParser.fieldDeclaration());
		
		// Set the new action.
		this.newAction = listener.getJavaAction();
		
		// Set the dependent actions.
		newAction.setDependentActions(dependentActions);
	}
	
	@Override
	public void enterImportDeclaration(ImportDeclarationContext importDeclaration) {
		this.newAction = new JavaImport(this.rawInput);
	}
	
	@Override
	public void enterMethodDeclaration(MethodDeclarationContext methodDeclarationContext) {
		
		// It's possible that methods are nested (for example inside of a class). We don't care about those, really so don't do any processing.
		if(this.newAction != null) {
			return;
		}
		
		// Find the relevant dependencies.
		Set<JavaAction> dependentActions = getDependentActions(findIdentifiers(methodDeclarationContext));
		
		// Go walk this specifically.
		Java8Parser newParser = getNewParser();
		
		// Pass through the raw input to the field listener.
		JavaMethodListener listener = new JavaMethodListener(rawInput);
		
		// Get the walker and walk with the new listener.
		ParseTreeWalker walker = new ParseTreeWalker();
		walker.walk(listener, newParser.methodDeclaration());
		
		// Set the new action.
		this.newAction = listener.getJavaAction();
		
		// Set the dependent actions.
		newAction.setDependentActions(dependentActions);
	}
	
	@Override
	public void enterExpressionStatement(ExpressionStatementContext statementContext) {
		
		// It's possible that expressions are nested (for example inside of a method). We don't care about those, really so don't do any processing.
		if(this.newAction != null) {
			return;
		}
		
		// Find the relevant dependencies.
		Set<JavaAction> dependentActions = getDependentActions(findIdentifiers(statementContext));
		
		// Go walk this specifically.
		Java8Parser newParser = getNewParser();
		
		// Pass through the raw input to the field listener.
		JavaExpressionListener listener = new JavaExpressionListener(rawInput);
		
		// Get the walker and walk with the new listener.
		ParseTreeWalker walker = new ParseTreeWalker();
		walker.walk(listener, newParser.expressionStatement());
		
		// Set the new action.
		this.newAction = listener.getJavaAction();
		
		// Set the dependent actions.
		newAction.setDependentActions(dependentActions);
	}
	
	@Override
	public void enterIfThenElseStatement(IfThenElseStatementContext ifThenElseContext) {
		
		// We could have a nested if/else statement, so make sure we DON'T try and do it again.
		if(this.newAction != null) {
			return;
		}

		// Find the relevant dependencies.
		Set<JavaAction> dependentActions = getDependentActions(findIdentifiers(ifThenElseContext));
		
		// The java loop.
		this.newAction = new JavaLoopOrIfStatement(this.rawInput);
		
		// Set the dependent actions.
		newAction.setDependentActions(dependentActions);
	}
	
	@Override
	public void enterIfThenStatement(IfThenStatementContext ifThenContext) {
		
		// We could have a nested if/else statement, so make sure we DON'T try and do it again.
		if(this.newAction != null) {
			return;
		}
		
		// Find the relevant dependencies.
		Set<JavaAction> dependentActions = getDependentActions(findIdentifiers(ifThenContext));
		
		// The java loop.
		this.newAction = new JavaLoopOrIfStatement(this.rawInput);
		
		// Set the dependent actions.
		newAction.setDependentActions(dependentActions);
	}
	
	@Override
	public void enterForStatement(ForStatementContext forStatementContext) {
		
		// We could have a nested if/else statement, so make sure we DON'T try and do it again.
		if(this.newAction != null) {
			return;
		}
		
		// Find the relevant dependencies.
		Set<JavaAction> dependentActions = getDependentActions(findIdentifiers(forStatementContext));
		
		// The java loop.
		this.newAction = new JavaLoopOrIfStatement(this.rawInput);
		
		// Set the dependent actions.
		newAction.setDependentActions(dependentActions);
	};
	
	@Override
	public void enterWhileStatement(WhileStatementContext whileStatementContext) {
		
		// We could have a nested if/else statement, so make sure we DON'T try and do it again.
		if(this.newAction != null) {
			return;
		}

		// Find the relevant dependencies.
		Set<JavaAction> dependentActions = getDependentActions(findIdentifiers(whileStatementContext));
		
		// The java loop.
		this.newAction = new JavaLoopOrIfStatement(this.rawInput);
		
		// Set the dependent actions.
		newAction.setDependentActions(dependentActions);
	}
	
	@Override
	public void enterDoStatement(DoStatementContext doStatementContext) {
		
		// We could have a nested if/else statement, so make sure we DON'T try and do it again.
		if(this.newAction != null) {
			return;
		}
		
		// Find the relevant dependencies.
		Set<JavaAction> dependentActions = getDependentActions(findIdentifiers(doStatementContext));
		
		// The java loop.
		this.newAction = new JavaLoopOrIfStatement(this.rawInput);
		
		// Set the dependent actions.
		newAction.setDependentActions(dependentActions);
	}
	
	@Override
	public void enterClassDeclaration(ClassDeclarationContext classDeclarationContext) {
		
		// Find the relevant dependencies.
		Set<JavaAction> dependentActions = getDependentActions(findIdentifiers(classDeclarationContext));
		
		// Get the normal class name.
		NormalClassDeclarationContext normalClass = classDeclarationContext.normalClassDeclaration();
		
		// If the normal class is null, then it could be an enum.
		if(normalClass == null) {
			EnumDeclarationContext enumClass = classDeclarationContext.enumDeclaration();
			this.newAction = new JavaEnum(this.rawInput, enumClass.Identifier().getText());
		}
		
		// Pull the class name out here.
		else {
			this.newAction = new JavaClass(this.rawInput, normalClass.Identifier().getText());
		}		
		
		// Set the dependent actions.
		newAction.setDependentActions(dependentActions);
	}
	
	@Override
	public void enterCatchClause(CatchClauseContext exceptionContext) {
		
		// These should be standalone, so we should never have an action already created.
		if(this.newAction != null) {
			return;
		}
		
		// Find the relevant dependencies.
		Set<JavaAction> dependentActions = getDependentActions(findIdentifiers(exceptionContext));
		
		// Get the exception name.
		String exceptionName = exceptionContext.catchFormalParameter().catchType().getText();
		
		// Add it into the exceptions.
		this.newAction = new JavaException(this.rawInput, exceptionName);
		
		// Dependent actions.
		this.newAction.setDependentActions(dependentActions);
		
		// Remove this exception if we're re-defining it.
		JavaInterpreterMaps.getInstance().removeException(exceptionName);
	};
	
	/**
	 * Get the java action from the nested listener we created.
	 * 
	 * @return {@link JavaAction} -- the new java action.
	 */
	public JavaAction getNewAction() {
		return this.newAction;
	}

	/**
	 * Method to determine the identifiers of the given parse tree. Brute force + recursion to see what parse trees
	 * actually have the "Identifier" method on them, and store their text in a list to be returned.
	 * 
	 * @param parseContext -- the parse tree.
	 * @return Set -- a string list of the identifiers (in order they were referenced).
	 */
	private Set<String> findIdentifiers(ParserRuleContext parseContext) {
		
		// Get the list of identifiers.
		Set<String> identifiers = new LinkedHashSet<String>();
		
		// Go through each of the children trees that we have.
		for(ParseTree aTree : parseContext.children) {
			
			try {
				
				// This is the identifier method that we wil invoke.
				Method identifierMethod = aTree.getClass().getMethod("Identifier", null);
				
				// The terminal node is the identifier as per the antlr grammar for java.
				TerminalNode node = null;
				
				// Invoke the method. We really should not have issues, but put them to the console if we do.
				try {
					if(identifierMethod.getReturnType().equals(List.class)) {
						List<TerminalNode> listOfNodes = (List<TerminalNode>) identifierMethod.invoke(aTree, null);
						
						// We seem to only ever have one in here, so just grab it.
						node = listOfNodes.get(0);
					}
					
					else {
						node = (TerminalNode) identifierMethod.invoke(aTree, null);
					}
				} 
				
				// Catch various exceptions here and re-throw the error.
				catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
					System.err.println("Exception... " + e);
				}
				
				// If we made it here, we have a method for identifiers.
				if(node != null) {
					identifiers.add(node.getText());
				}
			}
				
			// No method? Keep going.
			catch(NoSuchMethodException e) {
				;
			}
			
			// Recurse on all of the child nodes if they exist.
			if(aTree.getChildCount() > 0) {
				identifiers.addAll(findIdentifiers((ParserRuleContext)aTree));
			}			
		}
		
		// Return what we built up.
		return identifiers;
	}
	
	/**
	 * Method to find the relevent actions based on the identifiers. We will check each possible action type that might be referenced. If so,
	 * then we will have the string associated to it in the compiled class to be referenced.
	 * 
	 * @param relevantIdentifiers -- the names of the relevant identifiers.
	 * @return Set -- a list of dependent actions to return based on the identifiers.
	 */
	private Set<JavaAction> getDependentActions(Set<String> relevantIdentifiers) {
		
		// The return list.
		Set<JavaAction> dependentActions = new LinkedHashSet<JavaAction>();
		
		// Loop through the identifiers.
		for(String relevantIdentifer : relevantIdentifiers) {
			
			// Loop through each possible action that it could match.
			for(ActionType possibleAction : ActionType.values()) {
				
				// If we have a match, add it.
				if(JavaInterpreterMaps.getInstance().containsEntry(relevantIdentifer, possibleAction)) {
					dependentActions.addAll(JavaInterpreterMaps.getInstance().getEntry(relevantIdentifer, possibleAction));
				}
			}
		}
		
		// Return the built up list of dependents.
		return dependentActions;
	}
	
	/**
	 * Method to get the new parser.
	 * 
	 * @return {@link Java8Parser}, the parser.
	 */
	private Java8Parser getNewParser() {
		
		// Put it into a lexer.
    	Java8Lexer java8Lexer = new Java8Lexer(new ANTLRInputStream(this.rawInput));
    	
    	// Generate the token stream from that lexer.
    	CommonTokenStream tokenStream = new CommonTokenStream(java8Lexer);
    	
    	// Now return the parser.
    	Java8Parser parser = new Java8Parser(tokenStream);
    	
    	// Make the parser and lexer be quiet.
    	parser.removeErrorListeners();
    	java8Lexer.removeErrorListeners();
    	
    	// Now return.
    	return parser;
	}
}
